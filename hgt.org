#+TITLE: Urban Tree Height 
#+AUTHOR: erker
#+email: erker@wisc.edu
#+PROPERTY:  header-args:R :cache no :results output :exports both :comments link :session *R:hgt* :eval yes
#+PROPERTY:  header-args:sh :eval yes
#+startup: indent entitiespretty
#+FILETAGS: work allo
#+HTML_HEAD: <link rel="stylesheet" href="main.css" type="text/css">
#+OPTIONS: toc:nil num:t date:t author:nil
#+LATEX_HEADER: \usepackage[margin=1in]{geometry}
#+LATEX_HEADER: \usepackage{natbib}
##+LATEX_HEADER: \usepackage{chemformula}
#+latex_header: \usepackage{adjustbox}
#+LaTeX_HEADER: \RequirePackage{lineno} \def\linenumberfont{\normalfont\small\tt}
#+LATEX_HEADER: \hypersetup{colorlinks=true,linkcolor=black, citecolor=black, urlcolor=black}
#+latex_header: \usepackage{setspace} \doublespacing
#+LATEX_CLASS_OPTIONS: [12pt]
---------------------

* list of figures (for presentation and paper)

check my paper in stat consulting office to make sure I got it all

- raw data
  - lidar
    - lazers from a plane illustration
    - point cloud screen shot or gif
    - height difference from tree CHM.
  - hyperspectral imagery
    - aviris-ng
    - hyperspectral cube
    - leaf spectrum
    - 2015 flightlines over Madison.
    - merged trait maps over all of Madison.
  - tree inventories
    - street trees
      - get figure from poster with the summary statistics
    - hill farms
      - make figure like i have for street trees
    - atwood
      - make figure like i have for street trees
  - show tree points colored by growth
  - summary distributions for height growth by species...
  - growth by explanatory variable plots??
  - model plots???


* Introduction

Urban trees grow differently than their more rural counterparts
because of the challenges they face surviving amongst urban
infrastructure and because they are largely cultivated by humans (but
not for their wood).  For example, street trees are subject to damage
from vehicles, pedestrians, and poor soil conditions; urban trees tend
to be more open grown than rural trees; urban trees are pruned to
accomodate powerlines or for aesthetics, many urban trees are
irrigated and fertilized; the species composition in a city is often
different than its rural surrounding.  Urban conditions are not only
unique, but they are also more heterogeneous, which creates
variability in the growth of the urban forest at small spatial scales.

Urban forests are also critical components of the "green
infrastructure" meant to make cities more livable.  With over half the
human population living in urban areas, planting trees to provide
ecosystem services is seen as a way to make cities more livable.
These ecosystem services include habitat for wildlife, stormwater
runoff reduction, air quality improvement, and carbon sequestration.  

All these services are a function of growth, either directy such as
carbon sequestration, or indirectly such as stormwater runoff
reduction which is a function of tree size.  Therefore, understanding
urban tree growth is essential to estimating and projecting ecosystem
services into the future.  

Remote sensing technology provides an efficient way to collect
sufficient data on urban tree growth for detecting effect sizes that
may be small relative to the variability induced by the urban
environment.  Here we use two technologies that have only recently
become more available, repeat lidar and imaging spectroscopy.  Lidar
uses the reflection of lazer pulses to create 3 dimensional point
clouds of objects.  Using multiple years of lidar data we are able to
calculate growth in the the height of thousands of trees.  Imaging
spectroscopy 

to measure height
growth, to create indicies of canopy foliar
traits.  





** COMMENT comments







Understanding how trees grow in urban environments can help cities
better estimate and project 

- Why important
  - Urban environments are unique
  - Trees there provide services, one of which is carbon sequestration
    via growth
- Context
  - there is incredible variability in urban tree growth across a city
    due to variability in environment, and species
  - Remote sensing technology, specifically repeat lidar and imaging
    spectroscopy, allow for measurements of growth (from repeat lidar)
    for thousands of trees, which then can be combined with indicies
    of foliar traits (from imaging spectroscopy) to create large data
    for understanding urban tree growth
- Questions
  - What is the distribution of rates of urban tree height growth for different
    species in Madison?
    - this is the variability that I would seek to explain with
      environmental and trait data.
  - Do foliar trait indicies derived from imaging spectroscopy explain
    any of the variability in tree growth rates?
  - Do environmental factors (proximity to road, age of road?, percent
    impervious within 100m, topographic location.
- We hypothesize that we'll see effects expected from other studies
  - trees grow faster




* Methods

** Overview
In our study city, Madison, WI, we used two dates of lidar data (2009
and 2016) to estimate the height growth of trees over 7 years.
Inventories of street trees and two of Madison's neighborhoods,
provided species labels and diameter at breast height (DBH) for about
100 thousand trees.  In June 2015, NASA's Airborne Visible / Infrared
Imaging Spectometer - Next Generation (AVIRIS-NG) imaged the majority
of Madison.  Using predictive equations developed following
cite:singh_e_2015, we predicted canopy foliar traits: Nitrogen (% mass), N;
leaf mass per area (g/m^2), LMA; lignin (% mass), cellulose (% mass).
CHECK I HAVE ALL THESE.  In addition to foliar traits, we calculated
other environmental factors such as proximity to road and topographic
position. 

separate models for street trees and trees from the neighborhood inventories.

We then built a regression models to estimate the relationship of
environmental factors and foliar traits with growth, with separate
models for different species and tree contexts (street trees versus
neighborhood trees).

** Madison, WI: population and forests
Madison is a city of about 260,000 persons ([[https://www.census.gov/quickfacts/fact/table/madisoncitywisconsin/LND110210][USCensus]]), located in south
central Wisconsin.  Its climate is .... and the dominant forest type
is broadleaf deciduous.  Pre-european settlement forests were
dominated by oaks (Quercus), maples (Acer), and basswood (Tilia).
Now the most common street tree genera are Fraxinus, Acer, Gleditsia,
and Tilia, making up over 70% of all street trees.  Other common
genera in neighborhoods include: Picea, Thuja, Betula, and Pinus.

** Data

*** Tree inventories
The species of a tree encodes a suite of genetic factors that affect
growth rates and is therefore important to know when modeling tree
grwoth.  We used three tree inventories for species information.  The
first is the city's street tree inventory from 2011; the second is the
2012?  inventory of the Atwood neighborhood located on Madison's east
side and the north side of lake Monona, the third is the 2015-2016
inventory of the [[http://www.hillfarms.org/documents/UHFP_Tree_Report_2016.pdf][HillFarms neighborhood]] on Madison's west side FIGURE
HERE SHOWING INVENTORIES!!  give species breakdowns too.  These
inventories also provide information on DBH and tree condition.  

I need a figure showing the neighborhood inventories and the street
tree inventories too.

*** Light detection and ranging (lidar)

2009 lidar is .75 points per square meter. 2016 lidar is 

**** COMMENT comments on lidar
2009 lidar is not well documented.  I think it appers as 2010 lidar on
the wisconsinview website.

i need to get the average point density across all the tiles because
it varies.

.07 pts per sq ft.  = .75 pts per sq meter
.06 
*** other
- street tree inventory, hill farms and atwood inventories
- lidar
  - how modified to create heights
- imaging spectrsopty
  - modified to create indicies of canopy foliar traits
  - because of variations across images, we adjusted trait maps to one
    image and derived indicies of  foliar tratis.
- dem?
  - topographic position.
** Modeling



Using lidar from 2005, 2009, and 2016, we 

We 


create 

finding buildings: https://github.com/Jean-Romain/lidR/issues/209


2005 lidar might not be good enough for a general tree canopy layer,
but it should still be reliable for treee heights if I know the trees
location ( street trees).


** creating normalized lidar and doing best to filter out tree points
*** 2005 lidar
**** create lax
#+begin_src sh 
cd /media/erker/DATA_ERKER/data/madison_lidar/madison_lidar_2005/LiDAR_PointClouds_LAS/
/home/erker/Downloads/LAStools/bin/lasindex -i *.las
#+end_src

#+begin_src R
  library(lidR)
  l <- readLAS("/media/erker/DATA_ERKER/data/madison_lidar/madison_lidar_2005/LiDAR_PointClouds_LAS/tile014.las")
  plot(l, trim = 1000)
#+end_src


**** which have ground?
#+begin_src R
      library(stringr)
      f <- list.files("/media/erker/DATA_ERKER/data/madison_lidar/madison_lidar_2005/LiDAR_PointClouds_LAS/", pattern = ".*.las$", full.names = T)
      lapply(f, function(file) {
          i <- str_match(file, ".*tile([0-9]+).*.las$")[,2]
          l <- readLAS(file)
          n <- sum(l@data$Classification == 2)
          return(c(i, n))
    })
#+end_src

**** find ground
#+begin_src R
    ctg2005 <- catalog("/media/erker/DATA_ERKER/data/madison_lidar/madison_lidar_2005/LiDAR_PointClouds_LAS/")
    opt_output_files(ctg2005) <- "/media/erker/DATA_ERKER/dd/madison_lidar_2005_heights/normalized/ground/{ORIGINALFILENAME}_ground"
                                            #lasground(ctg2005, csf())
    ws = seq(6,24,6)
    th = seq(.1, 1.5, length.out = length(ws))

 lasground(ctg2005, pmf(ws, th))

  #  plot(ctg2005, map = T)


#+end_src

**** normalize
#+begin_src R 

  ctg2005ground <- catalog("/media/erker/DATA_ERKER/dd/madison_lidar_2005_heights/normalized/ground/")
  opt_output_files(ctg2005ground) <- "/media/erker/DATA_ERKER/dd/madison_lidar_2005_heights/normalized/{ORIGINALFILENAME}_normalized"
  lasnormalize(ctg2005ground, tin())

#+end_src

**** make lax for normalized
#+begin_src sh 
cd /media/erker/DATA_ERKER/dd/madison_lidar_2005_heights/normalized
/home/erker/Downloads/LAStools/bin/lasindex -i *.las
#+end_src

**** make normalized chm (this includes buildings, but excludes some points)
#+begin_src R
  library(lidR)
    ctg2005norm <- catalog("/media/erker/DATA_ERKER/dd/madison_lidar_2005_heights/normalized")
    opt_output_files(ctg2005norm) <- "/media/erker/DATA_ERKER/dd/madison_lidar_2005_heights/all_chm/{ORIGINALFILENAME}_chm"
    opt_filter(ctg2005norm) <- "-drop_z_above 120 -drop_z_below 6"
    chm <- grid_canopy(ctg2005norm, res = 3, p2r(1))
#+end_src

#+RESULTS:
: Be careful, some tiles seem to overlap each other. lidR may return incorrect outputs with edge artifacts when processing this catalog.
: Processing [>-------------------------------------------]   3% (1/34) eta: 39sError: filename exists; use overwrite=TRUE


#+BEGIN_SRC sh 
cd /media/erker/DATA_ERKER/dd/madison_lidar_2005_heights/all_chm/
gdal_translate -of GTiff -co "TILED=YES" -co "COMPRESS=LZW" grid_canopy.vrt ../height_norm_2005.tif
#+END_SRC


**** get extents
#+begin_src R

  dir <- "/media/erker/DATA_ERKER/dd/madison_lidar_2005_heights/normalized/"
        fs <-   list.files(dir,
                   pattern = ".las",
                   full.names = F)

    es <-     lapply(fs, function(f) {
        e <- extent(readLAS(paste0(dir, f), select = "", filter = "-keep_every_nth 100"))
        a <- as(e, "SpatialPolygons")
        a <- SpatialPolygonsDataFrame(a, data.frame(tile = f))
        return(a)
    })

  p <- do.call("rbind", es)
  shapefile(p, "/media/erker/DATA_ERKER/dd/madison_lidar_2005_heights/normalized/lidar_extents.shp")

#+end_src

#+RESULTS:


**** Get tree points
#+begin_src R
  library(lidR)
  dir <- "/media/erker/DATA_ERKER/dd/madison_lidar_2005_heights/normalized/"

  tile <- "tile014_ground_normalized.las"

  l <- readLAS(paste0(dir, tile), filter = "-drop_z_below 6")
  plot(l, trim = 100)

  e <- new("Extent", xmin = 826616.082997855, xmax = 828596.309091884, 
      ymin = 485978.641378534, ymax = 487311.522306307)

  l2 <- lasclip(l, e)

  writeLAS(l2, "test2005.las")


#+end_src

#+RESULTS:
: Error in rgl::rgl.setMouseCallbacks(button, begin, update, dev = dev,  : 
:   unused arguments (dev = dev, subscene = subscene)


#+begin_src R
  library(lidR)
  pct_x_is<- function(x, is) {
      return(list(pct_x = sum(x == is) / length(x)))
  }

  dir <- "/media/erker/DATA_ERKER/dd/madison_lidar_2005_heights/normalized/"

  tiles.w.trees <- list.files(dir, 
                              pattern = ".*.las")


  lapply(tiles.w.trees, function(tile) {

      l <- readLAS(paste0(dir, tile), filter = "-drop_z_below 6")

      proj4string(l) <- "+init=epsg:7599"

      lsp <- lasdetectshape(l, shp_plane(th1 = 4, th2 = 4, k = 9), "building")


      first.return.of.many <- (lsp@data$ReturnNumber == 1) & (lsp@data$NumberOfReturns > 1)
      lsp@data$building[first.return.of.many] <- FALSE

      pm <- point_metrics(lsp, ~pct_x_is(x = building, is = TRUE), k = 5)

      lsp@data$building[pm$pct_x <= .2] <- FALSE
      lsp@data$building[first.return.of.many] <- FALSE
  p
      lf <- lasfilter(lsp, building == FALSE)
      lfl <- lasdetectshape(lf, shp_line(th1 = 5, k = 8), "building")

      pm <- point_metrics(lfl, ~pct_x_is(x = building, is = TRUE), k = 20)

      lfl@data$building[pm$pct_x > .8] <- TRUE
      lfl@data$building[pm$pct_x < .2] <- FALSE
      lf <- lasfilter(lfl, building == FALSE)

      writeLAS(lf, paste0("/media/erker/DATA_ERKER/dd/madison_lidar_2005_heights/trees_lidar/",tile))

  })

#+end_src

**** make lax
#+BEGIN_SRC sh 
cd /media/erker/DATA_ERKER/dd/madison_lidar_2005_heights/trees_lidar
/home/erker/Downloads/LAStools/bin/lasindex -i *.las
#+END_SRC

#+RESULTS:

**** tree chm
#+begin_src R
  library(lidR)
    ctg2005trees <- catalog("/media/erker/DATA_ERKER/dd/madison_lidar_2005_heights/trees_lidar")
    opt_output_files(ctg2005trees) <- "/media/erker/DATA_ERKER/dd/madison_lidar_2005_heights/tree_chm/{ORIGINALFILENAME}_tree_chm"
    chm <- grid_canopy(ctg2005trees, res = 3, p2r(1))
#+end_src

#+RESULTS:
: Be careful, some tiles seem to overlap each other. lidR may return incorrect outputs with edge artifacts when processing this catalog.
: Processing [>-------------------------------------------]   3% (1/34) eta:  2mProcessing [==>-----------------------------------------]   6% (2/34) eta:  2mProcessing [===>----------------------------------------]   9% (3/34) eta:  2mProcessing [====>---------------------------------------]  12% (4/34) eta:  1mProcessing [=====>--------------------------------------]  15% (5/34) eta:  1mProcessing [=======>------------------------------------]  18% (6/34) eta:  1mProcessing [========>-----------------------------------]  21% (7/34) eta:  1mProcessing [=========>----------------------------------]  24% (8/34) eta:  1mProcessing [===========>--------------------------------]  26% (9/34) eta:  1mProcessing [============>------------------------------]  29% (10/34) eta:  1mProcessing [=============>-----------------------------]  32% (11/34) eta: 50sProcessing [==============>----------------------------]  35% (12/34) eta: 46sProcessing [===============>---------------------------]  38% (13/34) eta: 45sProcessing [=================>-------------------------]  41% (14/34) eta: 45sProcessing [==================>------------------------]  44% (15/34) eta: 43sProcessing [===================>-----------------------]  47% (16/34) eta: 42sProcessing [=====================>---------------------]  50% (17/34) eta: 38sProcessing [======================>--------------------]  53% (18/34) eta: 36sProcessing [=======================>-------------------]  56% (19/34) eta: 35sProcessing [========================>------------------]  59% (20/34) eta: 33sProcessing [==========================>----------------]  62% (21/34) eta: 31sProcessing [===========================>---------------]  65% (22/34) eta: 29sProcessing [============================>--------------]  68% (23/34) eta: 27sProcessing [=============================>-------------]  71% (24/34) eta: 25sProcessing [===============================>-----------]  74% (25/34) eta: 22sProcessing [================================>----------]  76% (26/34) eta: 19sProcessing [=================================>---------]  79% (27/34) eta: 17sProcessing [==================================>--------]  82% (28/34) eta: 15sProcessing [====================================>------]  85% (29/34) eta: 13sProcessing [=====================================>-----]  88% (30/34) eta: 10sProcessing [======================================>----]  91% (31/34) eta:  8sProcessing [=======================================>---]  94% (32/34) eta:  5sProcessing [=========================================>-]  97% (33/34) eta:  2sProcessing [===========================================] 100% (34/34) eta:  0s

#+BEGIN_SRC sh :session *a*
cd /media/erker/DATA_ERKER/dd/madison_lidar_2005_heights/tree_chm/
gdal_translate -of GTiff -co "TILED=YES" -co "COMPRESS=LZW" grid_canopy.vrt ../tree_height_norm_2005.tif
#+END_SRC

*** 2009 lidar

**** get tiles just over the tree inventory
This lidar covers all of dane county.  Only get the tiles that
intersect with the madison tree inventory.

#+name: tiles
#+begin_src R
    library(raster)
    library(rgeos)
    trees <- shapefile("/media/erker/DATA_ERKER/data/madison_tree_inventories/MadisonTrees.shp")
    tiles <- shapefile("/media/erker/DATA_ERKER/data/madison_lidar/madison_lidar_2009/TileIndex/StudyArea.shp")

    trees <- spTransform(trees, crs(tiles))

    o <- over(trees, tiles)
    o <- unique(o)

  tiles <- na.omit(o$LASClass)

#+end_src

#+RESULTS: tiles


**** find ground
#+begin_src R
library(lidR)

  lapply(tiles[37:101], function(tile) {
      tile.path <- paste0("/media/erker/DATA_ERKER/data/madison_lidar/madison_lidar_2009/LAS/", tile, ".LAS")
      las <- readLAS(tile.path)

      ws = seq(6,24,6)
      th = seq(.1, 1.5, length.out = length(ws))

      lg <- lasground(las, pmf(ws, th))

      writeLAS(lg, paste0("/media/erker/DATA_ERKER/data/madison_lidar/madison_lidar_2009/LAS_intersectTrees/",tile, "_ground.las"))
})
#+end_src


**** normalize
#+begin_src R
  ctg2009ground <- catalog("/media/erker/DATA_ERKER/data/madison_lidar/madison_lidar_2009/LAS_intersectTrees")
  opt_output_files(ctg2009ground) <- "/media/erker/DATA_ERKER/dd/madison_lidar_2009_heights/normalized/{ORIGINALFILENAME}_normalized"
  lasnormalize(ctg2009ground, tin())
#+end_src

**** make lax for normalized
#+begin_src sh :session b
cd /media/erker/DATA_ERKER/dd/madison_lidar_2009_heights/normalized
/home/erker/Downloads/LAStools/bin/lasindex -i *.las
#+end_src


**** make normalized chm (this includes buildings, but excludes some points)
#+begin_src R
  library(lidR)
    ctg2009norm <- catalog("/media/erker/DATA_ERKER/dd/madison_lidar_2009_heights/normalized")
    opt_output_files(ctg2009norm) <- "/media/erker/DATA_ERKER/dd/madison_lidar_2009_heights/all_chm/{ORIGINALFILENAME}_chm"
    opt_filter(ctg2009norm) <- "-drop_z_above 120 -drop_z_below 6"
    chm <- grid_canopy(ctg2009norm, res = 3, p2r(1))
#+end_src

#+RESULTS:
: Be careful, some tiles seem to overlap each other. lidR may return incorrect outputs with edge artifacts when processing this catalog.
: Processing [>-------------------------------------------]   3% (1/34) eta: 39sError: filename exists; use overwrite=TRUE


#+BEGIN_SRC sh :session *a*
cd /media/erker/DATA_ERKER/dd/madison_lidar_2009_heights/all_chm/
gdal_translate -of GTiff -co "TILED=YES" -co "COMPRESS=LZW" grid_canopy.vrt ../height_norm_2009.tif
#+END_SRC


**** get extents to select a downtown tile?
#+begin_src R

  dir <- "/media/erker/DATA_ERKER/dd/madison_lidar_2009_heights/normalized/"
        fs <-   list.files(dir,
                   pattern = ".las",
                   full.names = F)

    es <-     lapply(fs, function(f) {
        e <- extent(readLAS(paste0(dir, f), select = "", filter = "-keep_every_nth 100"))
        a <- as(e, "SpatialPolygons")
        a <- SpatialPolygonsDataFrame(a, data.frame(tile = f))
        return(a)
    })

  p <- do.call("rbind", es)
  shapefile(p, "/media/erker/DATA_ERKER/dd/madison_lidar_2009_heights/normalized/lidar_extents.shp")


#+end_src

#+RESULTS:
: There were 50 or more warnings (use warnings() to see the first 50)

same area as 2016:
"lc2t71007f_ground_normalized.las"
#+begin_src R

  l <- readLAS("/media/erker/DATA_ERKER/dd/madison_lidar_2009_heights/normalized/lc2t71007f_ground_normalized.las")
  plot(l)
  #chm <- grid_canopy(l, 3, p2r(1))
  #plot(chm)
  #e <- drawExtent()
  e <- new("Extent", xmin = 827161.463391346, xmax = 828579.428253175, 
      ymin = 486162.738356131, ymax = 487289.679000948)
  l1 <- lasclip(l, e)
  writeLAS(l1, "test2009.las")

#+end_src

#+RESULTS:
: Warning message:
: There are 0 points flagged 'synthetic'.
: Error in rgl::rgl.setMouseCallbacks(button, begin, update, dev = dev,  : 
:   unused arguments (dev = dev, subscene = subscene)

testing
#+begin_src R


      pct_x_is<- function(x, is) {
          return(list(pct_x = sum(x == is) / length(x)))
          }

  #l <- readLAS("test2009.las", filter = "-drop_z_below 6")
  l <- readLAS("test2009.las", filter = "-keep_first -drop_z_below 6 -thin_with_voxel 3")  # thin so that point density is constant?
  proj4string(l) <- "+init=epsg:7599"
  plot(l)

    lsp <- lasdetectshape(l, shp_plane(th1 = 6, th2 = 6, k = 8), "building")
    plot(lsp, color = "building")

    pm <- point_metrics(lsp, ~pct_x_is(x = building, is = TRUE), k = 30)

  lsp@data$pct_x <- pm$pct_x
  plot(lsp, color = "pct_x")

    lsp@data$building[pm$pct_x > .6] <- TRUE
    lsp@data$building[pm$pct_x < .4] <- FALSE

  plot(lsp, color = "building")

    lf <- lasfilter(lsp, building == FALSE)
    lfl <- lasdetectshape(lf, shp_line(th1 = 4, k = 15), "building")

  plot(lfl, color = "building")

    pm <- point_metrics(lfl, ~pct_x_is(x = building, is = TRUE), k = 30)

    lfl@data$building[pm$pct_x > .4] <- TRUE
    lfl@data$building[pm$pct_x < .1] <- FALSE
  lf <- lasfilter(lfl, building == FALSE)
  plot(lf)

#+end_src

extract tree points from the lidar, the variable point density might
make this challenging....
#+begin_src R

    library(lidR)

    pct_x_is<- function(x, is) {
        return(list(pct_x = sum(x == is) / length(x)))
    }

  dir <- "/media/erker/DATA_ERKER/dd/madison_lidar_2009_heights/normalized/"
  tiles.w.trees <- list.files(dir, pattern = ".*.las")

    lapply(tiles.w.trees, function(tile) {
        l <- readLAS(paste0(dir, tile), filter = "-keep_first -drop_z_below 6 -thin_with_voxel 3")
        proj4string(l) <- "+init=epsg:7599"

        lsp <- lasdetectshape(l, shp_plane(th1 = 6, th2 = 6, k = 8), "building")


        pm <- point_metrics(lsp, ~pct_x_is(x = building, is = TRUE), k = 30)

        lsp@data$building[pm$pct_x > .6] <- TRUE
        lsp@data$building[pm$pct_x < .4] <- FALSE



        lf <- lasfilter(lsp, building == FALSE)
        lfl <- lasdetectshape(lf, shp_line(th1 = 4, k = 15), "building")

        pm <- point_metrics(lfl, ~pct_x_is(x = building, is = TRUE), k = 30)

        lfl@data$building[pm$pct_x > .4] <- TRUE
        lfl@data$building[pm$pct_x < .1] <- FALSE
        lf <- lasfilter(lfl, building == FALSE)

        writeLAS(lf, paste0("/media/erker/DATA_ERKER/dd/madison_lidar_2009_heights/trees_lidar/",tile))

    })


#+end_src

create lax
#+begin_src sh

#+end_src

#+begin_src R
  library(lidR)
    ctg2009trees <- catalog("/media/erker/DATA_ERKER/dd/madison_lidar_2009_heights/trees_lidar")
    opt_output_files(ctg2009trees) <- "/media/erker/DATA_ERKER/dd/madison_lidar_2009_heights/tree_chm/{ORIGINALFILENAME}_tree_chm"
    chm <- grid_canopy(ctg2009trees, res = 3, p2r(1))
#+end_src


#+BEGIN_SRC sh :session *a* :results verbatim
cd /media/erker/DATA_ERKER/dd/madison_lidar_2009_heights/tree_chm/
gdal_translate -of GTiff -co "TILED=YES" -co "COMPRESS=LZW" grid_canopy.vrt ../tree_height_norm_2009.tif
#+END_SRC

#+RESULTS:
: 
: Input file size is 30105, 30256
: 0ERROR 5: lc2t81009f_ground_normalized_tree_chm.tif, band 1: Access window out of range in RasterIO().  Requested
: (0,0) of size 1773x256 on raster of 1771x1788.












chm, quick and easy algorithm
#+begin_src R
  library(lidR)
  ctg2009norm <- catalog("/media/erker/DATA_ERKER/dd/madison_lidar_2009_heights/normalized/")
  opt_output_files(ctg2009norm) <- "/media/erker/DATA_ERKER/dd/madison_lidar_2009_heights/chm/{ORIGINALFILENAME}_chm"
  grid_canopy(ctg2009norm, 4, p2r(6)) 
#+end_src

#+BEGIN_SRC sh
cd /media/erker/DATA_ERKER/dd/madison_lidar_2009_heights/

gdalbuildvrt chm2.vrt *chm2.tif

#+END_SRC

#+RESULTS:
: 0...10...20...30...40...50...60...70...80...90...100 - done.



chm, pitless algoright, too slow to be worth running.
#+begin_src R :eval no
  library(lidR)
  ctg2009norm <- catalog("/media/erker/DATA_ERKER/dd/madison_lidar_2009_heights/normalized/")
  opt_output_files(ctg2009norm) <- "/media/erker/DATA_ERKER/dd/madison_lidar_2009_heights/{ORIGINALFILENAME}_chm_pitfree"
  grid_canopy(ctg2009norm, 4, pitfree(c(0,6,12), c(0,1), subcircle = 6)) 
#+end_src


*** 2016 lidar
epsg 7599
**** normalize
#+begin_src R
  library(stringr)
  library(lidR)

      f <- list.files("/media/erker/DATA_ERKER/data/madison_lidar_2016/ftp.ssec.wisc.edu/pub/wisconsinview/lidar/Dane/Madison_2016_City_Delivery/Classified_LAS/LAS/", 
                    pattern = ".*.las$",
                    full.names = T)

                                      #file 72.las seems to have errors, so I skip it.

  lapply(f[204:231], function(file) {
      i <- str_match(file, "([0-9]+).las$")[,2]
      if (i != "72") {
          l <- readLAS(file)
          if(sum(l@data$Classification == 2) != 0) {                  # if there are some ground points
              ln <- lasnormalize(l, tin())
              writeLAS(ln, paste0("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/",i,"_normalized.las"))
          }
      }
  })

#+end_src

**** create lax (las index)

i had to download LAStools and run make in the directory.

#+BEGIN_SRC sh :session a
cd /media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/normalized_lidar/
/home/erker/Downloads/LAStools/bin/lasindex -i *.las

#+END_SRC

#+RESULTS:

**** make normalized chm (this includes buildings, but excludes some points)
#+begin_src R
  library(lidR)
    ctg2016norm <- catalog("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/normalized_lidar")
    opt_output_files(ctg2016norm) <- "/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/all_chm/{ORIGINALFILENAME}_chm"
    opt_filter(ctg2016norm) <- "-drop_z_above 120 -drop_z_below 6"
    chm <- grid_canopy(ctg2016norm, res = 3, p2r(1))
#+end_src

#+RESULTS:


#+BEGIN_SRC sh :session *a*
cd /media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/all_chm/
gdal_translate -of GTiff -co "TILED=YES" -co "COMPRESS=LZW" grid_canopy.vrt ../height_norm_2016.tif
#+END_SRC


**** find the tiles that overlap with the madison tree inventory data
#+begin_src R
  dir <- "/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/normalized_lidar/"
        fs <-   list.files(dir,
                   pattern = ".las",
                   full.names = F)

    es <-     lapply(fs, function(f) {
        e <- extent(readLAS(paste0(dir, f), select = "", filter = "-keep_every_nth 100"))
        a <- as(e, "SpatialPolygons")
        a <- SpatialPolygonsDataFrame(a, data.frame(tile = f))
        return(a)
    })

  p <- do.call("rbind", es)
                                          #shapefile(p, "/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/normalized_lidar/lidar_extents.shp")


  p <- shapefile("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/normalized_lidar/lidar_extents.shp")

  proj4string(p) <- "+init=epsg:7599"

  trees <- shapefile("/media/erker/DATA_ERKER/data/madison_tree_inventories/MadisonTrees.shp")
  trees <- spTransform(trees, crs(p))

  o <- over(trees, p)
  o <- unique(o)

  tiles.w.trees <- na.omit(o$tile)

#+end_src

#+RESULTS:

#+begin_src R :results output :file tiles.w.trees.txt
writeLines(tiles.w.trees)

#+end_src

#+RESULTS:
[[file:tiles.w.trees.txt]]

**** extract tree points from the lidar
#+begin_src R
  #   library(devtools)
  #   install_github("Jean-Romain/lidR", ref = "devel")

  tiles.w.trees <- readLines("tiles.w.trees.txt")

     library(lidR)

      pct_x_is<- function(x, is) {
          return(list(pct_x = sum(x == is) / length(x)))
          }

     lapply(tiles.w.trees, function(tile) {
         l <- readLAS(paste0(dir, tile))

         proj4string(l) <- "+init=epsg:7599"

         lsp <- lasdetectshape(l, shp_plane(th1 = 4, th2 = 4, k = 10), "building")

         pm <- point_metrics(lsp, ~pct_x_is(x = building, is = TRUE), k = 50)

         lsp@data$building[pm$pct_x > .6] <- TRUE
         lsp@data$building[pm$pct_x < .4] <- FALSE

         lf <- lasfilter(lsp, building == FALSE)
         lfl <- lasdetectshape(lf, shp_line(th1 = 4, k = 15), "building")

         pm <- point_metrics(lfl, ~pct_x_is(x = building, is = TRUE), k = 30)

         lfl@data$building[pm$pct_x > .4] <- TRUE
         lfl@data$building[pm$pct_x < .1] <- FALSE
         lf <- lasfilter(lfl, building == FALSE)

         writeLAS(lf, paste0("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/trees_lidar/",tile))

     })


#+end_src


This worked pretty well, but there are some towers that I missed.
I'll need to filter by height when I read in to make the chm.  Or
maybe do another clean up with point metrics.


#+begin_src R
    library(lidR)

    pct_x_is<- function(x, is) {
        return(list(pct_x = sum(x == is) / length(x)))
    }

    dir <- "/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/trees_lidar/"

  tiles.w.trees <- readLines("tiles.w.trees.txt")


    lapply(tiles.w.trees, function(tile) {
        l <- readLAS(paste0(dir, tile))

        proj4string(l) <- "+init=epsg:7599"

        lsp <- lasdetectshape(l, shp_line(th1 = 10, k = 5), "line")
        lsp@data$line[lsp@data$Z > 140] <- TRUE
        pm <- point_metrics(lsp, ~pct_x_is(x = line, is = TRUE), k = 10)
        lsp@data$line[pm$pct_x > .5] <- TRUE
        lsp@data$line[pm$pct_x < .3] <- FALSE
        pm <- point_metrics(lsp, ~pct_x_is(x = line, is = TRUE), k = 50)
        lsp@data$line[pm$pct_x > .4] <- TRUE
        lf <- lasfilter(lsp, Z < 140, line == FALSE)

        writeLAS(lf, paste0("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/trees_lidar_linefiltered/",tile))

    })


#+end_src

#+RESULTS:


**** Create the tree chm
#+begin_src R
  library(lidR)
    ctg2016trees <- catalog("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/trees_lidar_linefiltered/")
    opt_output_files(ctg2016trees) <- "/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/tree_chm/{ORIGINALFILENAME}_tree_chm"
    chm <- grid_canopy(ctg2016trees, res = 3, p2r(1))
#+end_src

#+RESULTS:


#+BEGIN_SRC sh :session *a*
cd /media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/tree_chm/
gdal_translate -of GTiff -co "TILED=YES" -co "COMPRESS=LZW" grid_canopy.vrt ../tree_height_norm_2016.tif
#+END_SRC


STOP here until I have a good tree chm for each year.




#+begin_src R
  library(raster)
  chm <- raster("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/tree_chm/102_normalized_tree_chm.tif")

  trees <- shapefile("/media/erker/DATA_ERKER/data/madison_tree_inventories/MadisonTrees.shp")
  trees <- spTransform(trees, crs("+init=epsg:7599"))
  crowns = silva2016(chm, trees, max_cr_factor = .6)()  # crowns may be biased small, but I'm focusing on height, so this is OK for now
  writeRaster(crowns, "test2.tif", overwrite = T)


#+end_src

#+RESULTS:






**** testing finding trees






#+begin_src R

   l <- readLAS("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/normalized_lidar/102_normalized.las",
                 filter = "-drop_class 9 -drop_z_above 200 -drop_z_below 0")
      chm <- grid_canopy(l, res = 3, p2r(1))
  plot(chm)
  #e <- drawExtent()

  e <- new("Extent", xmin = 826616.082997855, xmax = 828596.309091884, 
      ymin = 485978.641378534, ymax = 487311.522306307)

  l2 <- lasclip(l, e)

  writeLAS(l2, "test2016.las")

#+end_src

#+RESULTS:



possible plan, 

- get only those points that are certainly tree
- add back in points that are near the certainly tree points.



I need a rule that if a point is within 1m of something I know for
sure is a building, to call it a building.


try voxel
#+begin_src R
  #install_github("Jean-Romain/lidR", ref = "devel")
  library(lidR) 
  library(devtools)

  pct_x_is<- function(x, is) {
      return(list(pct_x = sum(x == is) / length(x)))
      }

  # point_metrics https://github.com/Jean-Romain/lidR/issues/276
  l <- readLAS("test2016.las", filter = "-drop_z_below 6 -keep_first")
  plot(l)
  lsp <- lasdetectshape(l, shp_plane(th1 = 4, th2 = 4, k = 10), "building")
  plot(lsp, color = "building", col = c("green", "red"))
  lsl <- lasdetectshape(l, shp_line(th1 = 2, k = 17), "building")
  plot(lsl, color = "building", col = c("green", "red"))

  l <- lasadddata(l, (lsp@data$building == T) | (lsl@data$building == T), "building")


  pm <- point_metrics(l, ~pct_x_is(x = building, is = TRUE), k = 20)

  l <- lasadddata(l, pm$pct_x, "pct_x")
  plot(l, color = "pct_x", trim = 1)
  l@data$building[pm$pct_x > .9] <- TRUE
  l@data$building[pm$pct_x < .4] <- FALSE
  plot(l, color = "building", col = c("green", "red"))


  pm <- point_metrics(lsp, ~pct_x_is(x = building, is = TRUE), k = 50)
  lsp@data$building[pm$pct_x > .6] <- TRUE
  lsp@data$building[pm$pct_x < .4] <- FALSE
  plot(lsp, color = "building", col = c("green", "red"))



  # try to get powerlines and tower
  lf <- lasfilter(lsp, building == FALSE)
  lfl <- lasdetectshape(lf, shp_line(th1 = 4, k = 15), "building")   #lfl <- lasdetectshape(lf, shp_line(th1 = 4, k = 15), "building")  
  plot(lfl, color = "building")
  pm <- point_metrics(lfl, ~pct_x_is(x = building, is = TRUE), k = 30)
  lfl <- lasadddata(lfl, pm$pct_x, "pct_x")
  plot(lfl, color = "pct_x", trim = 1)

  lfl@data$building[pm$pct_x > .4] <- TRUE
  lfl@data$building[pm$pct_x < .1] <- FALSE
  plot(lfl, color = "building", col = c("green", "red"))

#+end_src

***** point cloud viewer backedn
#+begin_src R
  l <- readLAS("test2016.las", filter = "-drop_z_below 6 -keep_first")
  plot(l, backend = "pcv")

#+end_src

***** CHM for just trees
#+begin_src R
  library(lidR)
    ctg2016norm <- catalog("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/normalized_lidar")
    opt_output_files(ctg2016norm) <- "/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/tree_chm/{ORIGINALFILENAME}_tree_chm"
    opt_filter(ctg2016norm) <- "-keep_class 2 -drop_z_above 200 -drop_z_below 0"
    chm <- grid_canopy(ctg2016norm, res = 3, p2r(1))
#+end_src




#+begin_src R

  f2 <- list.files("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/normalized_lidar/", ".*_normalized.las")

      lapply(f2, function(file) {
            i <- str_match(file, "([0-9]+).*.las$")[,2]
            l <- readLAS(file)
          if(sum(l@data$Classification == 2) != 0) {                  # if there are some ground points
            chm <- grid_canopy(l, res = 3, p2r(1))
            proj4string(chm) <- "+init=epsg:7599"
            writeRaster(chm, paste0("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/",i,"_.tif"), overwrite = T)
          }
      })



  ctg <- catalog("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/normalized_lidar/")
  opt_output_files(ctg) <- "/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/pitfree/{ORIGINALFILENAME}"
  chm.ctg <- grid_canopy(ctg, 3, pitfree(c(0,6,15,30,45), c(0,1), subcircle = 1.5))


      lapply(f2[44:length(f2)], function(file) {
            i <- str_match(file, "([0-9]+).*.las$")[,2]
            l <- readLAS(file)
          if(sum(l@data$Classification == 2) != 0) {                  # if there are some ground points
            chm <- grid_canopy(l, 3, pitfree(c(0,6,15,30,45), c(0,1), subcircle = 1.5))
            proj4string(chm) <- "+init=epsg:7599"
            writeRaster(chm, paste0("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/",i,"_pitfree.tif"), overwrite = T)
          }
      })

  f3 <- list.files("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/", ".*_pitfree.tif")


#+end_src

#+RESULTS:

#+BEGIN_SRC sh

cd /media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/

gdalbuildvrt height_.vrt *_.tif
gdalbuildvrt height_pitfree.vrt *_pitfree.tif

#+END_SRC

#+RESULTS:
| 0...10...20...30...40...50...60...70...80...90...100 | 0 | done. |
| 0...10...20...30...40...50...60...70...80...90...100 | 0 | done. |



segment trees
#+begin_src R
      library(lidR)
        i <- 205

      f <- paste0("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/",i,"_.tif")
      chm <- raster(f)


  fl <- paste0("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/normalized_lidar/",i,"_normalized.las")
  l <- readLAS(fl, filter = "-drop_z_below 0")
  proj4string(l) <- "+init=epsg:7599"
  chm <- grid_canopy(l, res = 1, pitfree(c(0,6,15,30,45), c(0,1), subcircle = 1.5))

  chme <- crop(chm, e)
  writeRaster(chme, "test.tif", overwrite = T)






  library(raster)
  chm <- raster("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/101_pitfree.tif")

  ttops <- tree_detection(chme, lmf(ws = function(h){h+3}, hmin = 6, shape = "circular"))
  crowns = silva2016(chme, ttops)()
  writeRaster(crowns, "test2.tif", overwrite = T)



  trees <- shapefile("/media/erker/DATA_ERKER/data/madison_tree_inventories/MadisonTrees.shp")
  trees <- spTransform(trees, crs("+init=epsg:7599"))


    ttops = tree_detection(l, lmf(100, hmin = 6, shape = "circular"))
    plot(chm)
    plot(ttops, add = T)


  ttops <- tree_detection(
  crowns = silva2016(chme, ttops)()
  writeRaster(crowns, "test2.tif", overwrite = T)
#+end_src

#+RESULTS:
: Local maximum filter: 79%Local maximum filter: 80%Local maximum filter: 81%Local maximum filter: 82%Local maximum filter: 83%Local maximum filter: 84%Local maximum filter: 85%Local maximum filter: 86%Local maximum filter: 87%Local maximum filter: 88%Local maximum filter: 89%Local maximum filter: 90%Local maximum filter: 91%Local maximum filter: 92%Local maximum filter: 93%Local maximum filter: 94%Local maximum filter: 95%Local maximum filter: 96%Local maximum filter: 97%Local maximum filter: 98%Local maximum filter: 99%Local maximum filter: 100%> > > > > > > > > > > > > > > > > > > > > Local maximum filter: 1%Local maximum filter: 2%Local maximum filter: 3%Local maximum filter: 4%Local maximum filter: 5%Local maximum filter: 6%Local maximum filter: 7%Local maximum filter: 8%Local maximum filter: 9%Local maximum filter: 10%Local maximum filter: 11%Local maximum filter: 12%Local maximum filter: 13%Local maximum filter: 14%Local maximum filter: 15%Local maximum filter: 16%Local maximum filter: 17%Local maximum filter: 18%Local maximum filter: 19%Local maximum filter: 20%Local maximum filter: 21%Local maximum filter: 22%Local maximum filter: 23%Local maximum filter: 24%Local maximum filter: 25%Local maximum filter: 26%Local maximum filter: 27%Local maximum filter: 28%Local maximum filter: 29%Local maximum filter: 30%71316 points below 0 found.
: Local maximum filter: 31%Processing [=================================>---------]  79% (27/34) eta:  8mLocal maximum filter: 32%Local maximum filter: 33%Local maximum filter: 34%Local maximum filter: 35%Local maximum filter: 36%Local maximum filter: 37%Local maximum filter: 38%Local maximum filter: 39%Local maximum filter: 40%Local maximum filter: 41%Local maximum filter: 42%Local maximum filter: 43%Local maximum filter: 44%Local maximum filter: 45%Local maximum filter: 46%Local maximum filter: 47%Local maximum filter: 48%Local maximum filter: 49%Local maximum filter: 50%Local maximum filter: 51%Local maximum filter: 52%Local maximum filter: 53%Local maximum filter: 54%Local maximum filter: 55%Local maximum filter: 56%Local maximum filter: 57%Local maximum filter: 58%Local maximum filter: 59%Local maximum filter: 60%Local maximum filter: 61%Local maximum filter: 62%Local maximum filter: 63%Local maximum filter: 64%Local maximum filter: 65%Local maximum filter: 66%Local maximum filter: 67%Local maximum filter: 68%Local maximum filter: 69%Local maximum filter: 70%Local maximum filter: 71%Local maximum filter: 72%Local maximum filter: 73%Local maximum filter: 74%Local maximum filter: 75%Local maximum filter: 76%Local maximum filter: 77%Local maximum filter: 78%Local maximum filter: 79%Local maximum filter: 80%Local maximum filter: 81%Local maximum filter: 82%Local maximum filter: 83%Local maximum filter: 84%Local maximum filter: 85%Local maximum filter: 86%Local maximum filter: 87%Local maximum filter: 88%Local maximum filter: 89%Local maximum filter: 90%Local maximum filter: 91%Local maximum filter: 92%Local maximum filter: 93%Local maximum filter: 94%Local maximum filter: 95%Local maximum filter: 96%Local maximum filter: 97%Local maximum filter: 98%Local maximum filter: 99%Local maximum filter: 100%> > > > > + + Error: unexpected symbol in:
: "crowns = silva2016(chme, ttops)()
: writeRaster"









#+begin_src R
  library(lidR)
  ctg <- catalog("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/normalized_lidar/")

i <- 205

  fl <- paste0("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/normalized_lidar/",i,"_normalized.las")
  fh <- 
  l <- readLAS(f) #should specify only spatial coordinates

  l <- lastrees(l, li2012())

#+end_src

#+RESULTS:
: 1924 points below 0 found.

***** old stuff




CHM for multiple returns (approximately trees)
#+begin_src R
  library(lidR)
    ctg2016norm <- catalog("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/normalized_lidar")
    opt_output_files(ctg2016norm) <- "/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/multiple_chm/{ORIGINALFILENAME}_tree_chm"
    opt_filter(ctg2016norm) <- "-drop_single -drop_z_above 200 -drop_z_below 0"
    chm <- grid_canopy(ctg2016norm, res = 3, p2r(1))
#+end_src

#+RESULTS:


the multiple return approach also included building edges.  I need to find a way to just get tree points
#+begin_src R
      ctg2016norm <- catalog("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/normalized_lidar")
      opt_output_files(ctg2016norm) <- "/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/tree_las/{ORIGINALFILENAME}_tree_chm"
      opt_filter(ctg2016norm) <- "-drop_z_above 200 -drop_z_below 0"

  dir <- "/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/normalized_lidar/"
    files <- list.files(dir, pattern = ".*.las$",
                        full.names = F)

    lapply(files, function(f) {
        l <- readLAS(paste0(dir,f))
        ls <- lasdetectshape(l, shp_line(th1 = 10, k = 5), "Colinear")
        lsp <- lasdetectshape(ls, shp_plane(th1 = 4, th2 = 4, k = 11), "Coplanar")
        lsp@data[(!lsp@data$Coplanar) & (!lsp@data$Colinear) & (lsp@data$ReturnNumber == 1) & (lsp@data$NumberOfReturns > 1) & (lsp@data$Intensity < 100)]$Classification <- 5L
        writeLAS(lsp, paste0("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/normalized_lidar_wtree/",f))
  })



#+end_src

#+RESULTS:

#+begin_src R
  library(lidR)
    ctg2016norm <- catalog("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/normalized_lidar_wtree")
    opt_output_files(ctg2016norm) <- "/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/tree_chm/{ORIGINALFILENAME}_chm"
    opt_filter(ctg2016norm) <- "-drop_single -drop_z_above 200 -drop_z_below 0 -keep_class 5"
    chm <- grid_canopy(ctg2016norm, res = 3, p2r(1))
#+end_src

#+RESULTS:

















*** 2017 lidar

**** get metadata and reports
#+BEGIN_SRC sh
cd /home/erker/hgt_data/dane_lidar_2017/
wget -r ftp://ftp.ssec.wisc.edu/pub/wisconsinview/lidar/Dane/Dane_2017_3DEP_Delivery/Metadata/
wget -r ftp://ftp.ssec.wisc.edu/pub/wisconsinview/lidar/Dane/Dane_2017_3DEP_Delivery/Reports/
#+END_SRC
**** download which tiles intersect with tree
download tiles
#+BEGIN_SRC sh
cd /home/erker/hgt_data/dane_lidar_2017/
wget -r ftp://ftp.ssec.wisc.edu/pub/wisconsinview/lidar/Dane/Dane_2017_3DEP_Delivery/Tile_Index/
#+END_SRC

find tiles that intersect
#+begin_src R
  library(raster)
  tiles <- shapefile("/home/erker/hgt_data/dane_lidar_2017/ftp.ssec.wisc.edu/pub/wisconsinview/lidar/Dane/Dane_2017_3DEP_Delivery/Tile_Index/DaneCo_WI_Tile_Index.shp")

  trees <- shapefile("/home/erker/hgt_data/madison_tree_inventories/MadisonTrees_WithAttributes.shp")

  trees <- spTransform(trees, crs(tiles))

  tree.tiles <- over(trees, tiles)

  tree.tiles.u <- unique(tree.tiles)

#+end_src

save out to file
#+begin_src R :file tree_tiles_2017.txt
  writeLines(tree.tiles.u$Name_Final)
#+end_src

#+RESULTS:
[[file:tree_tiles_2017.txt]]

Download those tiles from ftp
#+BEGIN_SRC sh :session *a*

cd /home/erker/hgt_data/dane_lidar_2017/ftp.ssec.wisc.edu/pub/wisconsinview/lidar/Dane/Dane_2017_3DEP_Delivery/Classified_LAS/USGS/

while IFS= read -r line;
do
tile=${line}_usgs.las
wget ftp://ftp.ssec.wisc.edu/pub/wisconsinview/lidar/Dane/Dane_2017_3DEP_Delivery/Classified_LAS/USGS/$tile
done < ~/git/hgt/tree_tiles_2017.txt

#+END_SRC

**** think about checking out their raster dems
#+BEGIN_SRC sh



ftp://ftp.ssec.wisc.edu/pub/wisconsinview/lidar/Dane/Dane_2017_3DEP_Delivery/Raster_DEM_Tiles/


#+END_SRC

** modeling

maybe use a gam with a smoother for the effect of initial height on
growth rate.

y ~ b * height

b ~ s(initial.height) + foliar traits + environment (proximity to road etc)

** adjusting chms
see this paper:
https://www.tandfonline.com/doi/abs/10.5589/m06-030
** comparing CHMs - more for visualization in 2d
*** difference in chm 2016 - 2009

#+begin_src R
  library(raster)
  r2016 <- raster("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/height_norm_2016.tif")
  r2009 <- raster("/media/erker/DATA_ERKER/dd/madison_lidar_2009_heights/height_norm_2009.tif")
  diff <- r2016 - r2009
  writeRaster(diff, "/media/erker/DATA_ERKER/dd/hgt/difference_height_all_2016-2009.tif")

#+end_src

#+RESULTS:
: Error in .local(.Object, ...) : 
: 
: Error in .rasterObjectFromFile(x, band = band, objecttype = "RasterLayer",  : 
:   Cannot create a RasterLayer object from this file. (file does not exist)
: Error: object 'r2009' not found

*** difference in tree chm 2016 - 2009

#+begin_src R
    library(raster)
    r2016 <- raster("/media/erker/DATA_ERKER/dd/madison_lidar_2016_heights/tree_height_norm_2016.tif")
    r2009 <- raster("/media/erker/DATA_ERKER/dd/madison_lidar_2009_heights/tree_height_norm_2009.tif")
  r6e <- crop(r2016, e)
  r9e <- crop(r2009, e)

  r6e[is.na(r6e)] <- 0
  r9e[is.na(r9e)] <- 0

  s <- stack(r6e, r9e)

    diff <- overlay(r6e, r9e, fun = function(x,y) {x - y})



    writeRaster(diff, "/media/erker/DATA_ERKER/dd/hgt/difference_height_tree_2016-2009.tif", overwrite = T)

  diff[diff == 0] <- NA

  diffsmooth <- focal(diff,  w=matrix(1/9,nrow=3,ncol=3))

  writeRaster(diffsmooth, "/media/erker/DATA_ERKER/dd/hgt/difference_height_tree_2016-2009_smoothed.tif", overwrite = T)


  r6es <- focal(r6e,  w=matrix(1/9,nrow=3,ncol=3))
  r9es <- focal(r9e,  w=matrix(1/9,nrow=3,ncol=3))

  r6t <- r6es > 6
  r9t <- r9es > 6


  difft <- overlay(r6t, r9t, fun = function(x,y) {x - y})
  writeRaster(difft, "/media/erker/DATA_ERKER/dd/hgt/difference_height_tree_2016-2009_tree_y_n.tif", overwrite = T)
#+end_src

#+RESULTS:
: Error in .local(.Object, ...) : 
: 
: Error in .rasterObjectFromFile(x, band = band, objecttype = "RasterLayer",  : 
:   Cannot create a RasterLayer object from this file. (file does not exist)
: Error: object 'r2009' not found


** extract heights from normalized lidar at location of trees

** I could potentially sub sample the 2017 down to the point density of 2005 to estimate the 2005 bias, then correct for it?  

This would give me one more year.  5 years: 2005, 2009, 2010, 2016,
and 2017 would be real nice.

** extract heights from normalized lidar at location of trees---------  i SHOULD probably do this from chm for speed 

** look at data?
#+begin_src R
  library(dplyr)
  library(tidyr)
library(stringr)
library(ggplot2)
  d <- tae@data
  dg <- d %>%
      select(UID, Genus, height2005, height2009, height2016) %>%
      gather(., year, height, -Genus, -UID) %>%
    mutate(year = as.numeric(str_extract(year, "[0-9]{4}")))
  str(dg)
#+end_src

#+RESULTS:
: 
: 'data.frame':	1233 obs. of  4 variables:
:  $ UID   : chr  "ST08437" "ST08464" "ST08504" "ST08505" ...
:  $ Genus : chr  "Stump" "Juniperus" "Ginkgo" "Acer" ...
:  $ year  : num  2005 2005 2005 2005 2005 ...
:  $ height: num  23.6 -Inf -Inf 25 23.5 ...

#+begin_src R :exports results :results graphics :file figs/sample_growth.png :height 800 :width 1000 :res 120
dgf <- filter(dg, !Genus %in% c("Stump", "Vacant"))
dgf <- filter(dg, Genus %in% c("Fraxinus", "Gleditsia", "Acer", "Tilia", "Ulmus", "Syringa", "Prunus"))
ggplot(dgf, aes(x = year, y = height, color = Genus, group = UID)) + geom_line()
#+end_src

#+RESULTS:
[[file:figs/sample_growth.png]]

#+begin_src R :exports results :results graphics :file figs/sample_growth_facetGenus.png :height 800 :width 1000 :res 120
  ggplot(dgf, aes(x = year, y = height, color = Genus, group = UID)) + geom_line() +
    facet_wrap(~Genus)
#+end_src

#+RESULTS:
[[file:figs/sample_growth_facetGenus.png]]

#+begin_src R :exports results :results graphics :file figs/sample_growth_fraxinus.png :height 800 :width 1000 :res 120
  dgff <- filter(dgf, Genus == "Fraxinus")
    ggplot(dgff, aes(x = year, y = height, group = UID)) + geom_line() +
      coord_cartesian(y = c(20, 70)) +
      facet_wrap(~UID)

#+end_src

#+RESULTS:
[[file:figs/sample_growth_fraxinus.png]]


* papers
https://link.springer.com/article/10.1186/s40663-018-0146-y

file:///home/erker/Downloads/remotesensing-10-00347.pdf

https://www.sciencedirect.com/science/article/pii/S0034425717302316#f0005

https://www.tandfonline.com/doi/abs/10.5589/m06-030

* old stuff
 







p
